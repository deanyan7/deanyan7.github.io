<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[资料整理]]></title>
    <url>%2F2017%2F08%2F18%2F%E5%90%84%E7%B1%BB%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[iOS Objectice-CiOS常用第三方库iOS Swift 面试&amp;工作-博主\博文iOS-UIApplication简介iOS开发常用三方库、插件、知名博客iOS上架各类问题汇总iOS各类小技巧总结iOS:使用贝塞尔曲线绘制图表（折线图、柱状图、饼状图）禅与 Objective-C 编程艺术iOS-Core-Animation-Advanced-TechniquesiOS10 适配、Xcode8配置总结UITextView/UITextField检测并过滤Emoji表情符号iOS 手势解锁功能iOS 保持界面流畅的技巧UICollectionView动画iOS 视频播放的四种方式UITableView 优化技巧苹果开发者账号及邓白氏编码的申请An iOS library to natively render After Effects vector animations iOS面试题 swiftSwift 语言指南Swift guideSwift写服务器Swift-航歌-编程社区Swift 实现格瓦拉转场iOS 常用加密方法39个优秀的Swift UI开源库Swift笔试面试题库 心灵鸡汤 19-24岁做什么事才能少走冤枉路25-30岁如何找到自己的毕生事业？内外兼修·程序员成长之路程序员之路——一个老程序员对刚上大学的学弟学妹的忠告写给程序员的有效学习方法为了不让彼此错过，在您做出决定之前，请给我1分钟的面谈机会，好吗？谢谢！投资理财，从这里开始程序员技术练级攻略程序员的本质编程超过 30 年，我是如何避开倦怠期的？ 算法与编程技巧 [数据结构、算法] 的资源推荐算法相关文章索引算法学习之路23 种设计模式-java实现图说设计模式编程技术教程Leetcode 算法题解 git Git本地项目上传 &amp; SourceTree &amp; GitHub 简单使用git教程-廖雪峰 C/C++ 写给大家看的设计模式 - C/C++ 的奇技淫巧C语言入门教程：c语言从入门到精通 书籍推荐总览 英语学习推荐一个合格的程序员应该读过哪些书一些经典的计算机书籍有哪些你看了以后大呼过瘾的编程书？Google Interview University编程类开放书籍荟萃免费的编程中文书籍索引free-programming-booksIT eBooks(下载)给编程生涯充电的 10 本书推荐编程技术书列表总有你要的编程书单（GitHub)程序员的书籍资源free-programming-books/free-programming-books.md at master · EbookFoundation/free-programming-booksStuQ 技能图谱（全套13张） 网站合集 虾皮工作室鸟哥笔记数据分析网Dev Store自学编程的12个网站PPT速效装逼的8个网站挑战最强大脑–10个烧脑编程挑战网站38个学习新技能的最佳网站16个小众却很实用的网站（程序员 向） 文档编辑 Latex Python Python教程-豆瓣Django 入门教程Python 的练手项目推荐Python 网络爬虫实战项目代码大全Python代码风格指南Python 实战Python之禅文章集锦59个Python使用技巧Python 2.7教程 廖雪峰Python 3教程 廖雪峰左手程序员，右手作家：你必须会的Jupyter NotebookIntro to Data Structures — pandas 0.20.3 documentationGroup By: split-apply-combineWorking with missing data Machine Learning 统计学Machine-Learning软件工程师的机器学习斯坦福大学机器学习个人笔记完整版（附所有视频和字幕）斯坦福机器学习笔记数据科学技能树机器学习算法的基本知识（使用Python和R代码）深度学习入门系列，用白话文的方式让你看得懂学的快Values of the Pearson Correlation程序猿的数据科学与机器学习实战手册人工智能公开课]]></content>
      <categories>
        <category>资料集合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Numpy的使用]]></title>
    <url>%2F2017%2F08%2F17%2FNumpy%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[numpy数组的创建 生成0-10的一维数组123import numpy as npimport pandas as pdnp.arange(10) out: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 生成一个三行四列全为1的二维数组12np.ones([3, 4])np.ones(3) out: array([ 1., 1., 1.]) 生成一个二行二列全为0的二维数组12np.zeros([2, 2])np.zeros(5) out: array([ 0., 0., 0., 0., 0.]) 生成空数组12np.empty(4)np.empty([3, 4]) out: array([[ 1., 1., 1., 1.], [ 1., 1., 1., 1.], [ 1., 1., 1., 1.]]) numpy 数组的基本操作123456789101112131415arr = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])print 'shape -&gt;', arr.shape # 返回数组的行数和列数print 'dtype -&gt;', arr.dtype # 返回数组的数据类型print 'ravel -&gt;', arr.ravel() # 多维数组降为一维数组print 'flatten -&gt;', arr.flatten() # 多维数组降为一维数组# 两者的区别在于ravel方法生成的是原数组的视图，无需占有内存空间，但视图的改变会影响到原数组的变化。而flatten方法返回的是真实值，其值的改变并不会影响原数组的更改。print 'ndim -&gt;', arr.ndim # 数组的维数print 'size -&gt;', arr.size # 数组元素的个数print 'T -&gt;\n', arr.T # 数组的转置# 如果数组的数据类型为复数的话，real方法可以返回复数的实部，imag方法返回复数的虚部。print 'len -&gt;', len(arr) # 数组的行数print 'hstack -&gt; \n', np.hstack((arr, arr)) # 如果数组的数据类型为复数的话，real方法可以返回复数的实部，imag方法返回复数的虚部。print 'vstack -&gt;\n', np.vstack((arr, arr)) # 纵向拼接arr3和arr4两个数组，但必须满足两个数组的列数相同。 out: shape -&gt; (3, 4) dtype -&gt; int64 ravel -&gt; [ 1 2 3 4 5 6 7 8 9 10 11 12] flatten -&gt; [ 1 2 3 4 5 6 7 8 9 10 11 12] ndim -&gt; 2 size -&gt; 12 T -&gt; [[ 1 5 9] [ 2 6 10] [ 3 7 11] [ 4 8 12]] len -&gt; 3 hstack -&gt; [[ 1 2 3 4 1 2 3 4] [ 5 6 7 8 5 6 7 8] [ 9 10 11 12 9 10 11 12]] vstack -&gt; [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12] [ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] 123456789101112# reshape()函数和resize()函数可以重新设置数组的行数和列数arr2 = np.array(np.arange(20))print 'arr2 -&gt;', arr2# 通过reshape函数将一维数组设置为二维数组，且为4行5列的数组。rearr = arr2.reshape(4, 5)print 'reshape(4, 5) -&gt;\n', rearr# 通过resize函数会直接改变原数组的形状。arr2.resize(5, 4)print 'resize(5, 4) -&gt;\n', arr2# *通过resize函数会直接改变原数组的形状。* arr2 -&gt; [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19] reshape(4, 5) -&gt; [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]] resize(5, 4) -&gt; [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19]] 12345678# 数组转换：tolist将数组转换为列表，astype()强制转换数组的数据类型a = np.array(np.arange(24))a.resize(6, 4)b = a.tolist()print 'tolist -&gt;\n', b, type(b)c = a.astype(float)print 'astype -&gt;\n', c, c.dtype tolist -&gt; [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]] &lt;type &apos;list&apos;&gt; astype -&gt; [[ 0. 1. 2. 3.] [ 4. 5. 6. 7.] [ 8. 9. 10. 11.] [ 12. 13. 14. 15.] [ 16. 17. 18. 19.] [ 20. 21. 22. 23.]] float64 1234567# 一维数组元素的获取A = np.array(np.arange(10))print '第五个元素: ', A[4]print '前三个元素: ', A[:3]print '末尾两个元素: ', A[-2:]print '第一个开始步长为2的元素:', A[::2] 第五个元素: 4 前三个元素: [0 1 2] 末尾两个元素: [8 9] 第一个开始步长为2的元素: [0 2 4 6 8] 1234567891011121314# 二维数组元素的获取B = np.array(np.arange(12)).reshape(3,4)print 'B \n', Bprint '数组第二行: ', B[1]print '数组前两行: \n', B[:2] print '第一行与第三行: \n', B[[0, 2]]print '数组第一列: \n', B[:, 0]print '数组的后两列: \n', B[:, -2:]print '数组的第一列与第三列: \n', B[:, [0, 2]]print '按照指定顺序返回指定行: \n', B[[1, 2, 0]]print '返回指定的行与列: \n', B[[2,0,1]][:, [3, 1, 0, 2]]# 如果想使用比较简单的方式返回指定行以列的二维数组的话，可以使用ix_()函数B[np.ix_([2,0,1],[3, 1, 0, 2])] B [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 数组第二行: [4 5 6 7] 数组前两行: [[0 1 2 3] [4 5 6 7]] 第一行与第三行: [[ 0 1 2 3] [ 8 9 10 11]] 数组第一列: [0 4 8] 数组的后两列: [[ 2 3] [ 6 7] [10 11]] 数组的第一列与第三列: [[ 0 2] [ 4 6] [ 8 10]] 按照指定顺序返回指定行: [[ 4 5 6 7] [ 8 9 10 11] [ 0 1 2 3]] 返回指定的行与列: [[11 9 8 10] [ 3 1 0 2] [ 7 5 4 6]] array([[11, 9, 8, 10], [ 3, 1, 0, 2], [ 7, 5, 4, 6]]) 1234567891011# 布尔索引 -&gt; 即索引值为True和False，需要注意的是布尔索引必须输数组对象。log = np.array([True,False,False,True,True,False])arrL = np.array(np.arange(24)).reshape(6,4)print '返回所有为True的对应行: \n', arrL[log]print '通过负号筛选出所有为False的对应行: \n', arrL[~log]# 举一个场景，一维数组表示区域，二维数组表示观测值，如何选取目标区域的观测area = np.array(['A','B','A','C','A','B','D'])observes = np.array(np.arange(21)).reshape(7,3)print '返回所有A区域的观测: \n', observes[area == 'A']print '返回所有A区域和D区域的观测: \n', observes[(area == 'A') | (area == 'D')] 返回所有为True的对应行: [[ 0 1 2 3] [12 13 14 15] [16 17 18 19]] 通过负号筛选出所有为False的对应行: [[ 4 5 6 7] [ 8 9 10 11] [20 21 22 23]] 返回所有A区域的观测: [[ 0 1 2] [ 6 7 8] [12 13 14]] 返回所有A区域和D区域的观测: [[ 0 1 2] [ 6 7 8] [12 13 14] [18 19 20]] 1234567891011# 统计函数与线性代数计算arr11 = 5 - np.arange(1,13).reshape(4,3)arr12 = np.random.randint(1,10,size=12).reshape(4,3)print arr11print '每个元素的平方: \n', arr11 ** 2print '每个元素的平方根: \n', np.sqrt(arr11) # 负值无意义，返回nanprint '每个元素的指数值: \n', np.exp(arr11)print '每个元素的自然对数: \n', np.log(arr11)print '每个元素的绝对值: \n', np.abs(arr11) [[ 4 3 2] [ 1 0 -1] [-2 -3 -4] [-5 -6 -7]] 每个元素的平方: [[16 9 4] [ 1 0 1] [ 4 9 16] [25 36 49]] 每个元素的平方根: [[ 2. 1.73205081 1.41421356] [ 1. 0. nan] [ nan nan nan] [ nan nan nan]] 每个元素的指数值: [[ 5.45981500e+01 2.00855369e+01 7.38905610e+00] [ 2.71828183e+00 1.00000000e+00 3.67879441e-01] [ 1.35335283e-01 4.97870684e-02 1.83156389e-02] [ 6.73794700e-03 2.47875218e-03 9.11881966e-04]] 每个元素的自然对数: [[ 1.38629436 1.09861229 0.69314718] [ 0. -inf nan] [ nan nan nan] [ nan nan nan]] 每个元素的绝对值: [[4 3 2] [1 0 1] [2 3 4] [5 6 7]] 12345print '数组相加: \n', arr11 + arr12print '数组相减: \n', arr11 - arr12print '数组相乘: \n', arr11 * arr12print '数组相除: \n', arr11 / arr12print '数组取余: \n', arr11 % arr12 数组相加: [[ 6 4 10] [ 8 1 4] [ 4 2 -1] [ 4 -1 -1]] 数组相减: [[ 2 2 -6] [ -6 -1 -6] [ -8 -8 -7] [-14 -11 -13]] 数组相乘: [[ 8 3 16] [ 7 0 -5] [-12 -15 -12] [-45 -30 -42]] 数组相除: [[ 2 3 0] [ 0 0 -1] [-1 -1 -2] [-1 -2 -2]] 数组取余: [[0 0 2] [1 0 4] [4 2 2] [4 4 5]] 1234567# 统计运算函数print '计算所有元素的和: ', np.sum(arr11)print '对每一列求和: ', np.sum(arr11, axis = 0)print '对每一行求和: ', np.sum(arr11, axis = 1)print '对每一个元素求累积和（从上到下，从左到右的元素顺序）:', np.cumsum(arr11)print '计算每一列的累积和，并返回二维数组: \n', np.cumsum(arr11, axis = 0)print '计算每一行的累计积，并返回二维数组: \n', np.cumprod(arr11, axis = 0) 计算所有元素的和: -18 对每一列求和: [ -2 -6 -10] 对每一行求和: [ 9 0 -9 -18] 对每一个元素求累积和（从上到下，从左到右的元素顺序）: [ 4 7 9 10 10 9 7 4 0 -5 -11 -18] 计算每一列的累积和，并返回二维数组: [[ 4 3 2] [ 5 3 1] [ 3 0 -3] [ -2 -6 -10]] 计算每一行的累计积，并返回二维数组: [[ 4 3 2] [ 4 0 -2] [ -8 0 8] [ 40 0 -56]] 1234567891011print '计算所有元素的最小值: ', np.min(arr11)print '计算所有元素的最大值: ', np.max(arr11)print '计算所有元素的均值: ', np.mean(arr11)print '计算每一行的均值: ', np.mean(arr11, axis = 1)print '计算所有元素的中位数: ', np.median(arr11)print '计算每一列的中位数: ', np.median(arr11, axis = 0)print '计算所有元素的方差: ', np.var(arr11)print '计算所有元素的标准差: ', np.std(arr11)print '计算每一行的标准差: ', np.std(arr11, axis = 1)# numpy还有其他函数可以计算sign，ceil(&gt;=x的最小整数)，floor(&lt;=x的最大整数)，# modf(将浮点数的整数部分与小数部分分别存入两个独立的数组)，cos，arccos，sin，arcsin，tan，arctan等 计算所有元素的最小值: -7 计算所有元素的最大值: 4 计算所有元素的均值: -1.5 计算每一行的均值: [ 3. 0. -3. -6.] 计算所有元素的中位数: -1.5 计算每一列的中位数: [-0.5 -1.5 -2.5] 计算所有元素的方差: 11.9166666667 计算所有元素的标准差: 3.45205252953 计算每一行的标准差: [ 0.81649658 0.81649658 0.81649658 0.81649658] 12# where()np.where(arr11&lt;0, 'negtive', 'positive') array([[&apos;positive&apos;, &apos;positive&apos;, &apos;positive&apos;], [&apos;positive&apos;, &apos;positive&apos;, &apos;negtive&apos;], [&apos;negtive&apos;, &apos;negtive&apos;, &apos;negtive&apos;], [&apos;negtive&apos;, &apos;negtive&apos;, &apos;negtive&apos;]], dtype=&apos;|S8&apos;) 12# unique(x): 计算x的唯一元素, 并返回有序结果np.unique(arr11) array([-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) 12# union1d(x, y): 计算x和y的并集np.union1d(arr11, arr12) array([-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 12# setdiff1d(x,y):计算x和y的差集，即元素在x中，不在y中np.setdiff1d(arr11,arr12) array([-7, -6, -5, -4, -3, -2, -1, 0, 4]) 12# setxor1d(x,y):计算集合的对称差，即存在于一个数组中，但不同时存在于两个数组中np.setxor1d(arr11,arr12) array([-7, -6, -5, -4, -3, -2, -1, 0, 4, 5, 6, 7, 8, 9]) 12# in1d(x,y):判断x的元素是否包含于y中np.in1d(arr11,arr12) array([False, True, True, True, False, False, False, False, False, False, False, False], dtype=bool) 线性代数计算12# numpy可以进行线性代数方面的计算，如行列式、逆、迹、特征根、特征向量等arr13 = np.array([[1,2,3,5],[2,4,1,6],[1,1,4,3],[2,5,4,1]]) 12# 返回方阵的行列式np.linalg.det(arr13) 51.000000000000021 12# 返回方阵的逆np.linalg.inv(arr13) array([[-2.23529412, 1.05882353, 1.70588235, -0.29411765], [ 0.68627451, -0.25490196, -0.7254902 , 0.2745098 ], [ 0.19607843, -0.21568627, 0.07843137, 0.07843137], [ 0.25490196, 0.01960784, -0.09803922, -0.09803922]]) 12# 返回方阵的迹（对角线元素之和）np.trace(arr13) 10 12# 返回由特征根和特征向量组成的元组np.linalg.eig(arr13) (array([ 11.35035004, -3.99231852, -0.3732631 , 3.01523159]), array([[-0.4754174 , -0.48095078, -0.95004728, 0.19967185], [-0.60676806, -0.42159999, 0.28426325, -0.67482638], [-0.36135292, -0.16859677, 0.08708826, 0.70663129], [-0.52462832, 0.75000995, 0.09497472, -0.07357122]])) 12# 返回方阵的QR分解np.linalg.qr(arr13) (array([[-0.31622777, -0.07254763, -0.35574573, -0.87645982], [-0.63245553, -0.14509525, 0.75789308, -0.06741999], [-0.31622777, -0.79802388, -0.38668014, 0.33709993], [-0.63245553, 0.580381 , -0.38668014, 0.33709993]]), array([[-3.16227766, -6.64078309, -5.37587202, -6.95701085], [ 0. , 1.37840488, -1.23330963, -3.04700025], [ 0. , 0. , -3.40278524, 1.22190924], [ 0. , 0. , 0. , -3.4384193 ]])) 12# 返回方阵的奇异值分解np.linalg.svd(arr13) (array([[-0.50908395, 0.27580803, 0.35260559, -0.73514132], [-0.59475561, 0.4936665 , -0.53555663, 0.34020325], [-0.39377551, -0.10084917, 0.70979004, 0.57529852], [-0.48170545, -0.81856751, -0.29162732, -0.11340459]]), array([ 11.82715609, 4.35052602, 3.17710166, 0.31197297]), array([[-0.25836994, -0.52417446, -0.47551003, -0.65755329], [-0.10914615, -0.38326507, -0.54167613, 0.74012294], [-0.18632462, -0.68784764, 0.69085326, 0.12194478], [ 0.94160248, -0.32436807, -0.05655931, -0.07050652]])) 123456# 方阵的正真乘积运算print np.dot(arr13,arr13)arr14 = np.array([[1,-2,1],[0,2,-8],[-4,5,9]])vector = np.array([0,8,9])np.linalg.solve(arr14,vector) [[18 38 37 31] [23 51 38 43] [13 25 32 26] [18 33 31 53]] array([ 155., 88., 21.])]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[统计方法 许多场景下经常会根据所谓的经验之谈来对某些事件总结观点获得结论。所谓的经验之谈在非正式场合下，这类说辞没有太大的问题，然后大多数时候，我们需要有说服力的正经以及可靠的结论，经验之谈明显不能做到这一点。 经验之谈的缺点(同事也是影响有效调查的因素)： 观察数量少 数据的选择性偏差 确认偏差(一部分提供支持示例，一部分引用反例） 数据的不准确 统计方法的手段 收集数据: 使用大型的调查数据，这些往往是为了得出某个结论进行可靠地统计推断专门收集而来 描述性统计: 计算能总计数据的统计量, 评测各种数据的可视化方法（表格图形法） 探索性数据分析: 寻找模式、差异和其它能解决我们疑问的特征。同时检查不一致性，确认其局限性- 假设检验 估计: 由数据进行推断 描述性统计集中趋势 中心测量值 –&gt; 数据集中趋势的度量 众数: x轴上最高频率所对应的值（多众数无意义） 中位数: 按顺序排列数据, 最中间的一位或者两位的平均数，包含异常值时，比均值更适合 均值:算数平均数、调整平均数(去掉最大最小值)、加权平均数、几何平均数(几个数值[乘积]的[n次方根]) 分位数: 百分位数、四分位数(Q1、Q2、Q3, 即第25，50，75百分位数) 变异程度的度量 数据离散程度的度量 极差: max-min 四分位数间距(IQR): IQR = Q3 - Q1（中间50%数据的极差） 方差: [离差]平方求和的均值 //TODO: 公式: 总体方差与样本方差 标准偏差: 方差的正平方根（与原始数据的[单位度量]相同, 易于比较和解释） 分布形态的度量 偏度: 偏斜方向和程度(相对于正态分布) 对称分布: 众数 = 中位数 = 均值 正偏斜分布: 众数 &lt; 中位数 &lt; 均值 负偏斜分布 归一化 数据归一化（标准化）是机器学习/数据挖掘的一项基础工作，是数据预处理的重要一步。样本各个特征往往具有不同的分布范围，通过归一化将各个维度的特征值映射到相同区间，使得各特征值具有相同量纲，处于同一数量级。 归一化的方法 min-miax归一化 对各维特征值分别进行线性变换，使得各维特征值被映射到[0, 1]之间，转换函数如下： min-max归一化转换函数 其中max为某一维特征值的最大值，min为某一维特征值的最小值。这种方法有个缺陷就是当有新样本加入时，可能导致max和min的变化，需要重新定义。 z-score归一化 这种方法用各维的均值和标准差来归一化各维特征值，它的转换函数为： z-score归一化转换函数 经过处理后，各维特征值符合标准正态分布。 标准正态分布：曲线下方的面积是1; 众数=中位数=平均数, 关于均值左右对称 其中，μ为所有样本数据的均值，σ为所有样本数据的标准差。]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python代码优化]]></title>
    <url>%2F2017%2F08%2F07%2Fpython%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[变量交换 12345# 大部分编程语言交换两个值需要引入临时变量进行书写a, b = 1, 2# pythonic 写法a, b = b, aprint a, b 2 1 循环遍历区间元素 12345678910li = [i for i in range(10)]for i in li: print i# 或者for i in range(len(li)): print li[i] # pythonic 写法for i in xrange(6): print i 在python2中，xrang返回的是生成器对象， range返回的是列表对象，生成器对象比列表更节约内存，python3中只有range方法，直接返回生成器对象 带有索引位置的接遍历 12345678colors = ['red', 'yellow', 'black', 'blue', 'grey']# 遍历集合时如果需要使用到集合的索引位置时，直接对集合迭代是没有索引信息的for index in range(len(colors)): print index, '-&gt;', colors[index]# pythonic 写法for index, color in enumerate(colors): print index, color 0 -&gt; red 1 -&gt; yellow 2 -&gt; black 3 -&gt; blue 4 -&gt; grey 0 red 1 yellow 2 black 3 blue 4 grey 字符串连接与拆分 12345678910111213# 字符串连接普通方式是可以用 + 操作words = ['Thank', 'you', 'for', 'your', 'resubmission']s = words[0]for word in words[1:]: s += ' ' + wordprint s# pythonic 写法print ' '.join(words)# 字符串拆分print s.split(' ')# +每使用一次在内存中将生成一个新的字符串对象，造成无谓的内存浪费， join整个过程只会产生一个字符串对象 Thank you for your resubmission Thank you for your resubmission [&apos;Thank&apos;, &apos;you&apos;, &apos;for&apos;, &apos;your&apos;, &apos;resubmission&apos;] 打开、关闭文件 1234567891011# 执行文件操作时，最后必须进行文件的close操作，即使有异常，普通的方式是在finnally中显示的调用close方法f = open('text.txt')try: data = f.read()finally: f.close()# pythonic 写法with open('text.txt') as f: data = f.read()# 使用with关键字，系统会在执行完文件操作对象，自动关闭文件对象 列表推导式 1234567891011# 普通生产列表的方式res = []for i in range(4): res.append(i)print res# pythonic 写法# 生成 0-3的列表print [i for i in range(4)]# 生成 0-3 的奇数列表print [i for i in range(4) if i%2 != 0] [0, 1, 2, 3] [0, 1, 2, 3] [1, 3] 链式比较操作 1234567891011age = 18if age &gt; 15 and age &lt; 60: print 'younger'# pythonic 写法if 15 &lt; age &lt; 60: print 'younger' # 链式操作False == False == True#out: False younger younger False 三目运算符 12345# 在c语言或者其它语言中有三目运算符‘:’# 但是在Python之禅中: “There should be one— and preferably only one —obvious way to do it. ”。能用if else表达清楚逻辑运算，不需要增加另外一种方式b = 1text = 'true' if b == 1 else 'false'print text true else语句 1234567891011# 在python中，除了if外，其它的循环语句都有else语句 #pythonic 写法while False: passelse: print 'while'for i in range(1): passelse: print 'for' while for 字符串格式化 1234567891011# 字符串格式化拼接方式str1 = "preferably"str2 = "obvious way"str3 = "There should be one— and %s only one —%s to do it. " % (str1, str2)# pythonic 写法str4 = "There should be one— and &#123;s1&#125; only one —&#123;s2&#125; to do it. ".format(s1=str1, s2 = str2)#很难确定用format比%s代码量更少, 但是往往format方式更易于代码的理解print str3print str4 There should be one— and preferably only one —obvious way to do it. There should be one— and preferably only one —obvious way to do it. 生成器 1234567891011121314151617181920# 生成斐波拉契数列def fib(n): a, b = 0, 1 res = [] while b &lt; n: res.append(b) a, b = b, a+b return res# pythonic 写法def fib2(n): a, b = 0, 1 while a &lt; n: yield a a, b = b, a + b# 生成器的好处在于无需一次将所有的数据放入内存中，只有迭代元素时才返回该元素，列表是预先一次性将所有元素加载入内存，print fib(5)[2]for item in fib2(5): print item 2 0 1 1 2 3 字典元素获取与预设字典值 1234567891011121314151617181920212223242526272829303132333435# 1&gt; 字典元素的获取 dic = &#123;'name': 'foo'&#125;if dic.has_key('name'): print dic['name']else: print 'unknow'# pythonicprint dic.get('name', 'unknow')# 2&gt; 预设字典默认值# 通过 key 分组的时候，不得不每次检查 key 是否已经存在于字典中。data = [('foo', 10), ('bar', 20), ('foo', 39), ('bar', 49)]groups = &#123;&#125;for (key, value) in data: if key in groups: groups[key].append(value) else: groups[key] = [value]# pythonic 写法# 第一种方式groups2 = &#123;&#125;for (key, value) in data: groups2.setdefault(key, []).append(value)# 第二种方式from collections import defaultdictgroups3 = defaultdict(list)for (key, value) in data: groups3[key].append(value) print groupsprint groups2print groups3 foo foo {&apos;foo&apos;: [10, 39], &apos;bar&apos;: [20, 49]} {&apos;foo&apos;: [10, 39], &apos;bar&apos;: [20, 49]} defaultdict(&lt;type &apos;list&apos;&gt;, {&apos;foo&apos;: [10, 39], &apos;bar&apos;: [20, 49]})]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[category/DataAnalysis]]></title>
    <url>%2F2017%2F07%2F26%2FdescriptionStatistics%2F</url>
    <content type="text"><![CDATA[描述性统计-数值方法中心位置的度量 平均数: 是一种数据位置的度量，用以了解整体数据，平均数分为: 算数平均数: 适用于普通简单的较直观的表现中心位置 调整平均数: 删除p%大、小的数据后进行计算算数平均数 加权平均数(每个数据有权值) 几何平均数:当数据呈倍数关系或不对称分布时（增长率或生长率、动态发展速度） 平均数很容易受到极值的影响，因为数据并不能保证不存在异常的数据点。又是可以采用调整平均数计算平均数 中位数: 数据进行升序排序后，位于中间的数值。当数据存在异常点的时候，中位数比均值更适合衡量 众数: 数据集中出现次数最多的数据，代表数据的一般水平，当众数有多个时，称为多众数。多众数一般无意义。 分位数: 百分位数]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二十三年过往喧嚣]]></title>
    <url>%2F2017%2F07%2F26%2F%E8%BF%87%E5%BE%80%E5%96%A7%E5%9A%A3%2F</url>
    <content type="text"><![CDATA[过去就像回形针，把青春一页页的固定，然后变成了一本不被出版的书。 &emsp;&emsp;决定开始写下这第一篇博客时，或许是对自己人生的一种感悟，感悟过往种种，又或许是想要转变，思考过去二十几年的岁月。 &emsp;&emsp;回首过往的二十几年，有时很怀恋，怀恋过往青春，有时很憎恨，憎恨传统对人生带来的影响。但是不管怎么说，二十多年我挺过来了。现在仔细想想过去的生活，发现之前从来没有明白未来是什么意思。儿时的记忆没有太多，几乎都是三五个小伙伴四处疯、野的记忆，完全没有想过将来自己需要承担的东西很多很多。当踏入教室的那一刻起，不知不觉的，思想开始潜移默化的改变了，开始有了一种在笼子里太久了，厌倦了笼子里一成不变的生活，好想出去看看的感觉，但是那一刻认为，想要走出去，认为唯一的办法就是读书。但是后来发现，当我选择了读书的那一刻，一切的性质都变了 – 周围的目光，家庭的压力。还好在最后书没读好，但是还是走出去了，坚持到了大学，但是那些压力也给我自己造成了许多的心里创伤。 未来&emsp;&emsp; 高中应该是对于学生来说最美好的时段，同时也是最有价值的时段，但是不幸，我没有完全融入那段生活，但是多多少少也有点高中时期的美好，现在还是挺怀恋的，但是更多的是遗憾。但是到了大学，自由、放纵占据了生活，终于不用整天去面对繁重的书本，沉重的压力去学习，从来没有想过该去做些有价值的事情，将时间投入到什么地方。直到大三开始，才开始真正的思考，工作、就业的问题，才开始思考我未来需要的是什么，在哪里，当我走出校园的那一刻，我是以什么样的角色去立足于这个社会，甚至在毕业几年后自己何去何从，那个时候开始就自己的专业方向开始定位自己的角色，但是不幸，对社会认知理念太少，稀里糊涂的选择程序员的某个方向，直到今天，才开始重新定位自己、审视自己 &emsp;&emsp; 在学生时期很内向，脾气怪异，甚至是孤僻，社交活动很少，甚至不明白还有人心叵测这一说，现在回看，发现自己处于自己的内心时间，挥霍了太多青春，同时也失去了太多的改变自己的机遇。大学毕业的这一年，我也挥霍了一次青春，这是我最后悔的一次挥霍，这一次让我深深的需要深刻的反省自己，才让我进入那早该进入的性格改变期，改变自己挥霍时间、挥霍青春的性格，改变自己高傲、孤僻的性格，这一刻，认识到，真的需要踏出去了，能力很重要。 自省自省&emsp;&emsp;认识自己的问题才能更好的解决问题。反思自己现在的态度与行为，是否有积极主动的学？抱着什么样的念头去学？是否还在用别人的标准来衡量自己？是否还在为鸡毛蒜皮的是烦恼，不知轻重？ &emsp;&emsp;当今天重新审视自己的问题的时候，发现确确实实的存在这些问题，漫无目的的学，没有规划性的学习，内心强大的攀比心理，经常不知事情轻重。这一刻才明白体会到自律与自控力的重要，优秀需要一点点的积累，无法一步青云，术业有专攻。 读书&emsp;&emsp;现在每天都有读书的习惯，目前所看的书有技术方向、软技能方面的书，但是在读过一本书之后，是否有真正的理解书本的技巧，是否真的的有自己的理解，这也是开始写博客的初衷之一，只有记录，才能明白自己从读书里面真正的学到了什么，理解了什么。 写作&emsp;&emsp;开始这篇博客，就需要时刻记录自己的成长。写作需要深度思考，对文字的灵活运用能力，甚至在职场中，写作仍然是一种非常重要的能力。程序员的技术性文档，源码阅读后的深思理解记录，软件使用文档，技术书籍的读后感。 社交&emsp;&emsp;直到准备写这个地方的时候，才在深深的思考，社交是什么，甚至是询问自己，你有社交能力吗？社交需要走出去，用心去聆听，用心去体会，甚至是用心的去交流，情绪与性格会影响社交能力，需要调整心情，转变性格，平易近人。 锻炼&emsp;&emsp;成功需要身体作为基础，不然真的可能最后学习的内容是颈椎病康复指南，久坐的人一般都是出于亚健康状态，每周三两次锻炼或者周末骑行都是锻炼的一种方式。 技术方向&emsp;&emsp;省视自己过往二十几年的时间，最后悔的就是技术问题，很后悔在大学期间没有认真学好数学与计算机相关的理论知识，甚至是没有一门精通性的语言。大学主要课程语言是C/C++，大学的放纵，让我成功的避过了学好这些课程最好的时机，现在只能回头恶补，每一门技术方向，基础或许很简单，但是开始深入学习所选择的技术方向的时候，需要询问自己基础是否融会贯通。技术方向固然很重要，但是基础是技术的基石，根基不稳，技术也不会理解太通彻。 英语&emsp;&emsp;英语是现在头疼的一点，当真正省视技术方向时，发现大多的文档都是英语文档，甚至现在很多前沿技术性的文档也是英语文档，或许可以等待翻译，但是翻译周期长，甚至翻译的文档往往带有翻译者的个人看法在里面，同一篇文章，十个人读有十种不同的感悟。背单词、听、说、读、写，现在将这些所谓的后悔转变成现在去学习的动力，开启自己计划学习。 &emsp;&emsp;今天，在这里记录下自己对过往的总结，对现如今生活的不满意，接下来，就该用自己的整个人生去为自己拼搏，相信总会有成功的一天。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>记录</tag>
      </tags>
  </entry>
</search>